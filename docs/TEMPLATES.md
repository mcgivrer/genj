# genj Templates - Detailed Guide

## Overview

Templates are the foundation for project generation with **genj**. A template can be:
- A **folder** containing the project structure
- A compressed **ZIP file**

This document explains in detail how to create and structure a template, using `templates/basic-java/` as an example.

## Structure of the `templates/basic-java/` template

```
templates/basic-java/
├── README.md
├── pom.xml
├── .gitignore
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   └── ${PACKAGE}/
│   │   │       └── ${MAINCLASS}.java
│   │   └── resources/
│   │       └── application.properties
│   └── test/
│       ├── java/
│       │   └── ${PACKAGE}/
│       │       └── ${MAINCLASS}Test.java
│       └── resources/
├── .vscode/
│   ├── settings.json
│   └── launch.json
└── docs/
    └── architecture.md
```

## File Details

### 1. **README.md** - Project Documentation

```markdown
# ${PROJECT_NAME}

Java project generated by genj.

## Description

${PROJECT_VERSION}

## Author

${AUTHOR_NAME} (${AUTHOR_EMAIL})

## Year

© ${PROJECT_YEAR}

## Build

### With Maven
\`\`\`bash
mvn clean package
\`\`\`

### With Gradle
\`\`\`bash
gradle build
\`\`\`
```

**Variables replaced:**
- `${PROJECT_NAME}` → Project name
- `${PROJECT_VERSION}` → Project version
- `${AUTHOR_NAME}` → Author name
- `${AUTHOR_EMAIL}` → Author email
- `${PROJECT_YEAR}` → Current year

### 2. **pom.xml** - Maven Configuration

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>${PACKAGE}</groupId>
    <artifactId>${PROJECT_NAME}</artifactId>
    <version>${PROJECT_VERSION}</version>
    <packaging>jar</packaging>

    <name>${PROJECT_NAME}</name>
    <description>${PROJECT_NAME} project generated by genj</description>
    <url>https://github.com/yourusername/${PROJECT_NAME}</url>

    <developers>
        <developer>
            <name>${AUTHOR_NAME}</name>
            <email>${AUTHOR_EMAIL}</email>
        </developer>
    </developers>

    <properties>
        <maven.compiler.source>${JAVA}</maven.compiler.source>
        <maven.compiler.target>${JAVA}</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <!-- JUnit Platform Console Standalone -->
        <dependency>
            <groupId>org.junit.platform</groupId>
            <artifactId>junit-platform-console-standalone</artifactId>
            <version>1.10.0</version>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
                <configuration>
                    <source>${JAVA}</source>
                    <target>${JAVA}</target>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

**Variables replaced:**
- `${PACKAGE}` → Java package (com.example)
- `${PROJECT_NAME}` → Project name
- `${PROJECT_VERSION}` → Version
- `${AUTHOR_NAME}` → Author
- `${AUTHOR_EMAIL}` → Email
- `${JAVA}` → JDK version

### 3. **.gitignore** - Git Ignored Files

```
# Build files
target/
build/
dist/
*.class
*.jar
*.war

# IDE
.idea/
.vscode/
*.swp
*.swo
*~
.DS_Store

# Dependencies
node_modules/

# Logs
*.log
```

### 4. **src/main/java/${PACKAGE}/${MAINCLASS}.java** - Main Class

```java
package ${PACKAGE};

/**
 * ${PROJECT_NAME} - Main Application Class
 * 
 * Generated by genj
 * 
 * @author ${AUTHOR_NAME}
 * @version ${PROJECT_VERSION}
 */
public class ${MAINCLASS} {

    /**
     * Main entry point
     * @param args Command line arguments
     */
    public static void main(String[] args) {
        System.out.println("Welcome to ${PROJECT_NAME}!");
        System.out.println("Version: ${PROJECT_VERSION}");
        System.out.println("Author: ${AUTHOR_NAME}");
        System.out.println("Year: ${PROJECT_YEAR}");
        System.out.println("Vendor: ${VENDOR_NAME}");
    }
}
```

**Variables replaced:**
- `${PACKAGE}` → Java package
- `${MAINCLASS}` → Main class name
- `${PROJECT_NAME}` → Project name
- `${PROJECT_VERSION}` → Version
- `${AUTHOR_NAME}` → Author
- `${PROJECT_YEAR}` → Year
- `${VENDOR_NAME}` → Vendor

### 5. **src/main/resources/application.properties** - Application Properties

```properties
# Application configuration
app.name=${PROJECT_NAME}
app.version=${PROJECT_VERSION}
app.author=${AUTHOR_NAME}
app.vendor=${VENDOR_NAME}

# Logging
logging.level.root=INFO
logging.level.${PACKAGE}=DEBUG
```

### 6. **src/test/java/${PACKAGE}/${MAINCLASS}Test.java** - Unit Tests

```java
package ${PACKAGE};

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Unit tests for ${MAINCLASS}
 */
public class ${MAINCLASS}Test {

    @Test
    public void testApplicationStart() {
        assertNotNull(${MAINCLASS}.class);
    }

    @Test
    public void testPackageName() {
        String packageName = ${MAINCLASS}.class.getPackage().getName();
        assertEquals("${PACKAGE}", packageName);
    }
}
```

### 7. **.vscode/settings.json** - VSCode Configuration

```json
{
    "java.format.settings.url": ".vscode/java-formatter.xml",
    "java.project.sourcePaths": [
        "src/main/java",
        "src/main/resources",
        "src/test/java",
        "src/test/resources"
    ],
    "java.project.referencedLibraries": [
        "libs/**/*.jar"
    ],
    "java.project.outputPath": "target/classes",
    "[java]": {
        "editor.defaultFormatter": "redhat.java",
        "editor.formatOnSave": true
    }
}
```

### 8. **.vscode/launch.json** - Debug Configuration

```json
{
    "version": "0.2.0",
    "configurations": [
        {
            "type": "java",
            "name": "Launch ${MAINCLASS}",
            "request": "launch",
            "mainClass": "${PACKAGE}.${MAINCLASS}",
            "projectName": "${PROJECT_NAME}",
            "console": "integratedTerminal"
        }
    ]
}
```

### 9. **docs/architecture.md** - Architecture Documentation

```markdown
# Architecture - ${PROJECT_NAME}

## Overview

${PROJECT_NAME} is a Java application structured according to Maven best practices.

## Directory Structure

- **src/main/java** : Main source code
- **src/main/resources** : Resource files
- **src/test/java** : Unit tests
- **target** : Compiled artifacts

## Main Class

- **${MAINCLASS}** : Application entry point

## Technologies

- Java ${JAVA}
- Maven / Gradle
- JUnit for testing

## Author

${AUTHOR_NAME} (${AUTHOR_EMAIL})

## Version

${PROJECT_VERSION}
```

## Available Variables in Templates

| Variable | Example | Description |
|----------|---------|-------------|
| `${PROJECT_NAME}` | MyApp | Project name |
| `${AUTHOR_NAME}` | John Doe | Author name |
| `${AUTHOR_EMAIL}` | john@example.com | Author email |
| `${PROJECT_VERSION}` | 1.0.0 | Project version |
| `${PACKAGE}` | com.example.app | Java package (created as directory hierarchy) |
| `${MAINCLASS}` | Application | Main class name |
| `${PROJECT_YEAR}` | 2025 | Current year |
| `${JAVA}` | 21 | JDK version |
| `${VENDOR_NAME}` | My Company | Vendor name |

## Creating Your Own Template

### Step 1: Create the Structure

```bash
mkdir -p templates/my-template/src/main/java/${PACKAGE}
mkdir -p templates/my-template/src/test/java/${PACKAGE}
mkdir -p templates/my-template/.vscode
```

### Step 2: Add Files

Place your files in the structure, using replacement variables.

### Step 3: Use the Template

```bash
genj -t templates/my-template -d ./output -n MyProject -k com.mycompany
```

## Best Practices

1. **Use variables** for paths: `src/main/java/${PACKAGE}/`
2. **Document** files with comments
3. **Include tests** in `src/test/java/`
4. **Provide VSCode configuration** for a better developer experience
5. **Test** your template with different parameter combinations

## Example: Creating a Spring Boot Template

```
templates/spring-boot/
├── pom.xml (with Spring dependencies)
├── src/main/java/${PACKAGE}/
│   └── Application.java (with @SpringBootApplication)
├── src/main/resources/
│   ├── application.properties
│   └── application-dev.properties
└── .vscode/
    └── settings.json
```

## Compression as ZIP

To create a ZIP template:

```bash
cd templates
zip -r my-template.zip my-template/
```

Then use it with genj:

```bash
genj -t templates/my-template.zip -d ./output -n MyProject
```

## Limitations

- Binary files are copied without variable replacement
- The `${PACKAGE}` path is transformed into a directory hierarchy
- Variables are only replaced in text files detected as UTF-8