# genj Templates - Detailed Guide

## Overview

Templates are the foundation for project generation with **genj**. A template can be:
- A **folder** containing the project structure
- A compressed **ZIP file**

Templates can include a `.template` metadata file (JSON format) that provides information used by the `--list` and `--search` commands.

This document explains in detail how to create and structure a template, using `templates/basic-java/` as an example.

## Template Discovery

### Listing Templates

Users can discover available templates using the `--list` command:

[[[
genj --list
]]]

This displays all templates from:
- **System templates:** `/usr/share/genj/templates/`
- **User templates:** `~/.genj/`

### Searching Templates

Users can search for templates using the `--search` command (case-insensitive):

[[[
genj --search java
genj --search spring
genj -s gradle
]]]

Search is performed on:
- Template name
- Description
- Language
- Author
- Version
- Contact
- License
- Tags

## Structure of the `templates/basic-java/` template

[[[
templates/basic-java/
├── .template
├── README.md
├── pom.xml
├── .gitignore
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   └── ${PACKAGE}/
│   │   │       └── ${MAINCLASS}.java
│   │   └── resources/
│   │       └── application.properties
│   └── test/
│       ├── java/
│       │   └── ${PACKAGE}/
│       │       └── ${MAINCLASS}Test.java
│       └── resources/
├── .vscode/
│   ├── settings.json
│   └── launch.json
└── docs/
    └── architecture.md
]]]

## Template Metadata File: `.template`

The `.template` file is a JSON file at the root of the template that provides metadata for discovery and description.

### `.template` File Format

[[[
{
  "name": "Basic Java",
  "version": "1.0.0",
  "language": "Java",
  "description": "Basic Java project template with Maven support",
  "author": "Template Author",
  "contact": "author@example.com",
  "license": "MIT",
  "tags": ["java", "maven", "basic", "starter"],
  "created_at": "2025-12-02T10:00:00Z"
}
]]]

### Metadata Fields Explained

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `name` | string | Yes | Display name of the template |
| `version` | string | Yes | Semantic version of the template (e.g., "1.0.0") |
| `language` | string | Yes | Programming language(s) (e.g., "Java", "Java 21+") |
| `description` | string | Yes | Detailed description of template purpose and features |
| `author` | string | Yes | Name of the template creator |
| `contact` | string | Yes | Contact email of the template author |
| `license` | string | Yes | License type (e.g., "MIT", "Apache-2.0") |
| `tags` | array | Yes | Array of strings for categorization (e.g., ["java", "maven", "rest-api"]) |
| `created_at` | string | Yes | ISO 8601 timestamp of template creation (e.g., "2025-12-02T10:00:00Z") |

### Example: Comprehensive Metadata File

[[[
{
  "name": "Spring Boot REST API",
  "version": "2.0.0",
  "language": "Java 21+",
  "description": "Full-featured Spring Boot REST API template with integrated testing, containerization, and deployment configurations",
  "author": "Frédéric Delorme",
  "contact": "fred@example.com",
  "license": "MIT",
  "tags": ["java", "spring-boot", "rest-api", "gradle", "docker", "kubernetes"],
  "created_at": "2025-12-02T15:30:00Z"
}
]]]

## File Details

### 1. **`.template`** - Metadata File (NEW)

Already described above. This file is essential for template discovery via `--list` and `--search`.

### 2. **README.md** - Project Documentation

[[[
# ${PROJECT_NAME}

Java project generated by genj.

## Description

${PROJECT_VERSION}

## Author

${AUTHOR_NAME} (${AUTHOR_EMAIL})

## Year

© ${PROJECT_YEAR}

## Build

### With Maven
[[[bash
mvn clean package
]]]

### With Gradle
[[[bash
gradle build
]]]
]]]

**Variables replaced:**
- `${PROJECT_NAME}` → Project name
- `${PROJECT_VERSION}` → Project version
- `${AUTHOR_NAME}` → Author name
- `${AUTHOR_EMAIL}` → Author email
- `${PROJECT_YEAR}` → Current year

### 2. **pom.xml** - Maven Configuration

[[[
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>${PACKAGE}</groupId>
    <artifactId>${PROJECT_NAME}</artifactId>
    <version>${PROJECT_VERSION}</version>
    <packaging>jar</packaging>

    <name>${PROJECT_NAME}</name>
    <description>${PROJECT_NAME} project generated by genj</description>
    <url>https://github.com/yourusername/${PROJECT_NAME}</url>

    <developers>
        <developer>
            <name>${AUTHOR_NAME}</name>
            <email>${AUTHOR_EMAIL}</email>
        </developer>
    </developers>

    <properties>
        <maven.compiler.source>${JAVA}</maven.compiler.source>
        <maven.compiler.target>${JAVA}</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <!-- JUnit Platform Console Standalone -->
        <dependency>
            <groupId>org.junit.platform</groupId>
            <artifactId>junit-platform-console-standalone</artifactId>
            <version>1.10.0</version>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
                <configuration>
                    <source>${JAVA}</source>
                    <target>${JAVA}</target>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
]]]

**Variables replaced:**
- `${PACKAGE}` → Java package (com.example)
- `${PROJECT_NAME}` → Project name
- `${PROJECT_VERSION}` → Version
- `${AUTHOR_NAME}` → Author
- `${AUTHOR_EMAIL}` → Email
- `${JAVA}` → JDK version

### 3. **.gitignore** - Git Ignored Files

[[[
# Build files
target/
build/
dist/
*.class
*.jar
*.war

# IDE
.idea/
.vscode/
*.swp
*.swo
*~
.DS_Store

# Dependencies
node_modules/

# Logs
*.log
]]]

### 4. **src/main/java/${PACKAGE}/${MAINCLASS}.java** - Main Class

[[[
package ${PACKAGE};

/**
 * ${PROJECT_NAME} - Main Application Class
 * 
 * Generated by genj
 * 
 * @author ${AUTHOR_NAME}
 * @version ${PROJECT_VERSION}
 */
public class ${MAINCLASS} {

    /**
     * Main entry point
     * @param args Command line arguments
     */
    public static void main(String[] args) {
        System.out.println("Welcome to ${PROJECT_NAME}!");
        System.out.println("Version: ${PROJECT_VERSION}");
        System.out.println("Author: ${AUTHOR_NAME}");
        System.out.println("Year: ${PROJECT_YEAR}");
        System.out.println("Vendor: ${VENDOR_NAME}");
    }
}
]]]

**Variables replaced:**
- `${PACKAGE}` → Java package
- `${MAINCLASS}` → Main class name
- `${PROJECT_NAME}` → Project name
- `${PROJECT_VERSION}` → Version
- `${AUTHOR_NAME}` → Author
- `${PROJECT_YEAR}` → Year
- `${VENDOR_NAME}` → Vendor

### 5. **src/main/resources/application.properties** - Application Properties

[[[
# Application configuration
app.name=${PROJECT_NAME}
app.version=${PROJECT_VERSION}
app.author=${AUTHOR_NAME}
app.vendor=${VENDOR_NAME}

# Logging
logging.level.root=INFO
logging.level.${PACKAGE}=DEBUG
]]]

### 6. **src/test/java/${PACKAGE}/${MAINCLASS}Test.java** - Unit Tests

[[[
package ${PACKAGE};

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Unit tests for ${MAINCLASS}
 */
public class ${MAINCLASS}Test {

    @Test
    public void testApplicationStart() {
        assertNotNull(${MAINCLASS}.class);
    }

    @Test
    public void testPackageName() {
        String packageName = ${MAINCLASS}.class.getPackage().getName();
        assertEquals("${PACKAGE}", packageName);
    }
}
]]]

### 7. **.vscode/settings.json** - VSCode Configuration

[[[
{
    "java.format.settings.url": ".vscode/java-formatter.xml",
    "java.project.sourcePaths": [
        "src/main/java",
        "src/main/resources",
        "src/test/java",
        "src/test/resources"
    ],
    "java.project.referencedLibraries": [
        "libs/**/*.jar"
    ],
    "java.project.outputPath": "target/classes",
    "[java]": {
        "editor.defaultFormatter": "redhat.java",
        "editor.formatOnSave": true
    }
}
]]]

### 8. **.vscode/launch.json** - Debug Configuration

[[[
{
    "version": "0.2.0",
    "configurations": [
        {
            "type": "java",
            "name": "Launch ${MAINCLASS}",
            "request": "launch",
            "mainClass": "${PACKAGE}.${MAINCLASS}",
            "projectName": "${PROJECT_NAME}",
            "console": "integratedTerminal"
        }
    ]
}
]]]

### 9. **docs/architecture.md** - Architecture Documentation

[[[
# Architecture - ${PROJECT_NAME}

## Overview

${PROJECT_NAME} is a Java application structured according to Maven best practices.

## Directory Structure

- **src/main/java** : Main source code
- **src/main/resources** : Resource files
- **src/test/java** : Unit tests
- **target** : Compiled artifacts

## Main Class

- **${MAINCLASS}** : Application entry point

## Technologies

- Java ${JAVA}
- Maven / Gradle
- JUnit for testing

## Author

${AUTHOR_NAME} (${AUTHOR_EMAIL})

## Version

${PROJECT_VERSION}
]]]

## Available Variables in Templates

| Variable | Example | Description |
|----------|---------|-------------|
| `${PROJECT_NAME}` | MyApp | Project name |
| `${AUTHOR_NAME}` | John Doe | Author name |
| `${AUTHOR_EMAIL}` | john@example.com | Author email |
| `${PROJECT_VERSION}` | 1.0.0 | Project version |
| `${PACKAGE}` | com.example.app | Java package (created as directory hierarchy) |
| `${MAINCLASS}` | Application | Main class name |
| `${PROJECT_YEAR}` | 2025 | Current year |
| `${JAVA}` | 21 | JDK version |
| `${VENDOR_NAME}` | My Company | Vendor name |

## Creating Your Own Template

### Step 1: Create the Structure

[[[
mkdir -p templates/my-template/src/main/java/${PACKAGE}
mkdir -p templates/my-template/src/test/java/${PACKAGE}
mkdir -p templates/my-template/.vscode
]]]

### Step 2: Add Files

Place your files in the structure, using replacement variables.

### Step 3: Create Metadata File

Create `.template` in the root of your template:

[[[
cat > templates/my-template/.template << 'EOF'
{
  "name": "My Custom Template",
  "version": "1.0.0",
  "language": "Java",
  "description": "A custom template for my specific use case",
  "author": "Your Name",
  "contact": "you@example.com",
  "license": "MIT",
  "tags": ["custom", "mycompany"],
  "created_at": "2025-12-02T10:00:00Z"
}
EOF
]]]

### Step 4: Verify Metadata

Test your template with the `--list` and `--search` commands:

[[[
# Copy template to user directory
cp -r templates/my-template ~/.genj/

# List templates to verify metadata is displayed
genj --list

# Search by name or tag
genj --search my-template
]]]

### Step 5: Use the Template

[[[
genj -t my-template -d ./output -n MyProject -k com.mycompany
]]]

## Installing Templates

### System-wide Installation (requires root)

[[[
sudo cp -r templates/my-template /usr/share/genj/templates/
]]]

### User Installation

[[[
cp -r templates/my-template ~/.genj/
]]]

### ZIP Template Installation

[[[
# Create ZIP
cd templates
zip -r my-template.zip my-template/

# Install to user directory
mkdir -p ~/.genj
cp my-template.zip ~/.genj/

# Use template
genj -t my-template.zip -d ./output -n MyProject
]]]

## Best Practices

1. **Always include `.template` metadata** - Makes your template discoverable via `--list` and `--search`
2. **Use meaningful tags** - Helps users find your template (e.g., "spring-boot", "rest-api", "microservice")
3. **Write clear descriptions** - Explain template purpose and intended use case
4. **Use variables properly** - Follow the variable naming convention in paths and files
5. **Document your template** - Include README with usage instructions
6. **Include tests** - Provide `src/test/java/` with sample tests
7. **Provide VSCode configuration** - Better developer experience with `.vscode/` files
8. **Test your template** - Verify it works with different parameter combinations
9. **Verify metadata syntax** - Ensure `.template` JSON is valid
10. **Keep metadata updated** - Update version and created_at timestamps

## Example: Creating a Spring Boot Template

[[[
templates/spring-boot/
├── .template
├── README.md
├── pom.xml
├── src/main/java/${PACKAGE}/
│   └── Application.java (with @SpringBootApplication)
├── src/main/resources/
│   ├── application.properties
│   └── application-dev.properties
└── .vscode/
    └── settings.json
]]]

**.template metadata:**
[[[
{
  "name": "Spring Boot Starter",
  "version": "2.0.0",
  "language": "Java 21+",
  "description": "Spring Boot REST API starter template with integrated testing",
  "author": "Your Team",
  "contact": "team@example.com",
  "license": "Apache-2.0",
  "tags": ["spring-boot", "rest-api", "maven", "starter"],
  "created_at": "2025-12-02T10:00:00Z"
}
]]]

## Compression as ZIP

To create a ZIP template:

[[[
cd templates
zip -r my-template.zip my-template/
]]]

The `.template` file in the ZIP will be automatically detected when using `--list` and `--search`.

Then use it with genj:

[[[
genj -t templates/my-template.zip -d ./output -n MyProject
]]]

Or install and reference by name:

[[[
cp templates/my-template.zip ~/.genj/
genj -t my-template.zip -d ./output -n MyProject
]]]

## Template Search and Discovery

### System-wide and User Templates

Templates are searched in the following order:
1. `/usr/share/genj/templates/` - System-wide templates
2. `~/.genj/` - User-specific templates

Use `genj --list` to see all available templates from both locations.

### Metadata-driven Discovery

Each template's `.template` metadata file enables powerful discovery:

[[[
# Find all Java templates
genj --search java

# Find Spring-related templates
genj --search spring

# Find templates from a specific author
genj --search "author-name"

# Find templates with specific tags
genj --search rest-api
genj --search microservice
]]]

## Limitations

- Binary files are copied without variable replacement
- The `${PACKAGE}` path is transformed into a directory hierarchy
- Variables are only replaced in text files detected as UTF-8
- Metadata fields are case-sensitive in the `.template` JSON file
- The `.template` file must be valid JSON for metadata to be displayed

## Troubleshooting Template Discovery

### Template not appearing in `--list`

1. Verify the template is in `/usr/share/genj/templates/` or `~/.genj/`
2. Check that the template has a `.template` metadata file at the root
3. Validate `.template` JSON syntax (use `jq` or online JSON validator)
4. Verify file permissions (template directory should be readable)

### Metadata not displaying correctly

1. Check `.template` JSON file for syntax errors
2. Verify all required metadata fields are present
3. Check field values for special characters that need escaping
4. Verify `created_at` uses ISO 8601 format (YYYY-MM-DDTHH:MM:SSZ)

### Search not finding templates

1. Use `genj --list` to verify template exists
2. Check if search term matches template name, description, or tags (case-insensitive)
3. Verify template has `.template` metadata file
4. Try searching with shorter terms or common keywords